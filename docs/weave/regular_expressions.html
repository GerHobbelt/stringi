<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Regular Expressions &mdash; stringi</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://stringi.gagolewski.com/weave/regular_expressions.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Collation" href="collation.html" />
    <link rel="prev" title="Code-Pointwise Comparing" href="codepoint_comparing.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> stringi
          

          
          </a>

          
            
            
              <div class="version">
                1.7.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">stringi</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing <em>stringi</em></a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi">Source Code (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi/issues">Bug Tracker and Feature Suggestions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cran.r-project.org/package=stringi">CRAN Entry</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="design_principles.html">General Design Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_operations.html">Basic String Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="codepoint_comparing.html">Code-Pointwise Comparing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Regular Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#matching-individual-characters">Matching Individual Characters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matching-any-character">Matching Any Character</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-character-sets">Defining Character Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complementing-sets">Complementing Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-code-point-ranges">Defining Code Point Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-predefined-character-sets">Using Predefined Character Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#avoiding-posix-classes">Avoiding POSIX Classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#alternating-and-grouping-subexpressions">Alternating and Grouping Subexpressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#alternation-operator">Alternation Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grouping-subexpressions">Grouping Subexpressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-grouping-parentheses">Non-grouping Parentheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantifiers">Quantifiers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#performance-notes">Performance Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#capture-groups-and-references-thereto">Capture Groups and References Thereto</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extracting-capture-group-matches">Extracting Capture Group Matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locating-capture-group-matches">Locating Capture Group Matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#replacing-with-capture-group-matches">Replacing with Capture Group Matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#back-referencing">Back-Referencing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#anchoring">Anchoring</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matching-at-the-beginning-or-end-of-a-string">Matching at the Beginning or End of a String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matching-at-word-boundaries">Matching at Word Boundaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#looking-behind-and-ahead">Looking Behind and Ahead</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="collation.html">Collation</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_operations.html">Other Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_output.html">Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html">Example Use Case: Data Preparation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../rapi.html">R Package <em>stringi</em> Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://deepr.gagolewski.com">Deep R Programming</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stringx.gagolewski.com/">stringx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">JStatSoft Paper</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/ExampleRcppStringi">C++ API — Rcpp Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../news.html">What Is New in <em>stringi</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../z_bibliography.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">stringi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Regular Expressions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="codepoint_comparing.html" class="btn btn-neutral float-left" title="Code-Pointwise Comparing" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="collation.html" class="btn btn-neutral float-right" title="Collation" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="regular-expressions">
<span id="sec-regex"></span><h1>Regular Expressions<a class="headerlink" href="#regular-expressions" title="Permalink to this heading"></a></h1>
<blockquote>
<div><p>This tutorial is based on the <a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">paper on <em>stringi</em></a> that was published the <em>Journal of Statistical Software</em>; see <span id="id1">[<a class="reference internal" href="../z_bibliography.html#id3" title="M. Gagolewski. stringi: Fast and portable character string processing in R. Journal of Statistical Software, 103(2):1–59, 2022. doi:10.18637/jss.v103.i02.">Gag22</a>]</span>. To learn more about R, check out Marek’s recent open-access (free!) textbook <a class="reference external" href="https://deepr.gagolewski.com/"><em>Deep R Programming</em></a> <span id="id2">[<a class="reference internal" href="../z_bibliography.html#id4" title="M. Gagolewski. Deep R Programming. Zenodo, Melbourne, 2023. ISBN 978-0-6455719-2-9 (reserved). early draft. URL: https://deepr.gagolewski.com/, doi:10.5281/zenodo.7490464.">Gag23</a>]</span>.</p>
</div></blockquote>
<p>Regular expressions (regexes) provide concise grammar for
defining systematic patterns that can be sought in character strings.
Examples of such patterns include: specific fixed substrings, emojis of
any kind, stand-alone sequences of lower-case Latin letters (“words”),
substrings that can be interpreted as real numbers (with or without
fractional parts, also in scientific notation), telephone numbers, email
addresses, or URLs.</p>
<p>Theoretically, the concept of regular pattern matching dates back to the
so-called regular languages and finite state automata <span id="id3">[<a class="reference internal" href="../z_bibliography.html#id26" title="S.C. Kleene. Representation of events in nerve nets and finite automata. Technical Report RM-704, The RAND Corporation, Santa Monica, CA, 1951. URL \url https://www.rand.org/content/dam/rand/pubs/research_memoranda/2008/RM704.pdf.">Kle51</a>]</span>, see
also <span id="id4">[<a class="reference internal" href="../z_bibliography.html#id29" title="J.E. Hopcroft and J.D. Ullman. Introduction to Automata Theory, Languages, and Computation. Addison-Wesley, 1979.">HU79</a>]</span> and <span id="id5">[<a class="reference internal" href="../z_bibliography.html#id27" title="M. Rabin and D. Scott. Finite automata and their decision problems. IBM Journal of Research and Development, 3:114–125, 1959.">RS59</a>]</span>. Regexes in the form
as we know it today
have already been present in one of the pre-Unix implementations of the
command-line text editor <em>qed</em> (<span id="id6">[<a class="reference internal" href="../z_bibliography.html#id28" title="D.M. Ritchie and K.L. Thompson. QED text editor. Technical Report 70107-002, Bell Telephone Laboratories, Inc., 1970. URL: https://wayback.archive-it.org/all/20150203071645/http://cm.bell-labs.com/cm/cs/who/dmr/qedman.pdf.">RT70</a>]</span>; the predecessor of the
well-known <em>sed</em>).</p>
<p>Base R gives access to two different regex matching engines (via
functions such as <code class="docutils literal notranslate"><span class="pre">gregexpr()</span></code> and <code class="docutils literal notranslate"><span class="pre">grep()</span></code>):</p>
<ul class="simple">
<li><p>ERE (extended regular expressions that conform to the
POSIX.2-1992 standard;
via the <a class="reference external" href="https://github.com/laurikari/tre/"><em>TRE</em></a> library);
used by default,</p></li>
<li><p>PCRE (Perl-compatible regular expressions;
via the <a class="reference external" href="https://www.pcre.org/"><em>PCRE2</em></a> library);
activated when <code class="docutils literal notranslate"><span class="pre">perl=TRUE</span></code> is set.</p></li>
</ul>
<p>Other matchers are implemented in the <a class="reference external" href="https://CRAN.R-project.org/package=ore"><em>ore</em></a>, <a class="reference external" href="https://github.com/qinwf/re2r"><em>re2r</em></a>,
and <a class="reference external" href="https://github.com/girishji/re2/"><em>re2</em></a> packages.</p>
<p><em>Stringi</em>, on the other hand, provides access to the regex engine
implemented in <a class="reference external" href="https://icu.unicode.org/"><em>ICU</em></a>,
which was inspired by Java’s <em>util.regex</em> in
<em>JDK 1.4</em>. Their syntax is mostly compatible with that of <em>PCRE</em>, although
certain more advanced facets might not be supported (e.g., recursive
patterns). On the other hand, <em>ICU</em> regexes fully conform to the
<a class="reference external" href="https://www.unicode.org/reports/tr18/">Unicode Technical Standard #18</a>
and hence provide comprehensive support for Unicode.</p>
<p>It is worth noting that most programming languages and advanced
text editors and development environments
(including <a class="reference external" href="https://kate-editor.org/"><em>Kate</em></a>,
<a class="reference external" href="https://www.eclipse.org/ide/"><em>Eclipse</em></a>,
<a class="reference external" href="https://code.visualstudio.com/"><em>VSCode</em></a>,
and <a class="reference external" href="https://www.rstudio.com/products/rstudio/"><em>RStudio</em></a>) support finding or replacing patterns with
regexes. Therefore, they should be amongst the instruments at every data
scientist’s disposal. One general introduction to regexes is <span id="id7">[<a class="reference internal" href="../z_bibliography.html#id25" title="J.E.F. Friedl. Mastering Regular Expressions. O'Reilly, 2006.">Fri06</a>]</span>.
The <em>ICU</em> flavour is summarised at
<a class="reference external" href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">https://unicode-org.github.io/icu/userguide/strings/regexp.html</a>.</p>
<p>Below we provide a concise yet comprehensive introduction to the topic
from the perspective of the <em>stringi</em> package users. This time we will
use the pattern search routines whose names end with the <code class="docutils literal notranslate"><span class="pre">*_regex()</span></code>
suffix. Apart from <code class="docutils literal notranslate"><span class="pre">stri_detect_regex()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_locate_all_regex()</span></code>, and
so forth, in <a class="reference internal" href="#sec-capturing"><span class="std std-ref">Capture Groups and References Thereto</span></a> we introduce <code class="docutils literal notranslate"><span class="pre">stri_match_all_regex()</span></code>.
Moreover, the table below lists the available options for the regex
engine.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Option</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to enable (full) case-insensitive matching</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">comments</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to allow white spaces and comments within patterns</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dot_all</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; if set, “<code class="docutils literal notranslate"><span class="pre">.</span></code>” matches line terminators; otherwise its matching stops at a line end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">literal</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to treat the entire pattern as a literal string; note that in most cases the code-pointwise string search facilities (<code class="docutils literal notranslate"><span class="pre">*_fixed()</span></code> functions described in <a class="reference internal" href="codepoint_comparing.html#sec-fixed"><span class="std std-ref">Code-Pointwise Comparing</span></a> are faster</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">multi_line</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; if set, “<code class="docutils literal notranslate"><span class="pre">$</span></code>” and “<code class="docutils literal notranslate"><span class="pre">^</span></code>” recognise line terminators within a string; otherwise, they match only at start and end of the input</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unix_lines</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; when enabled, only the Unix line ending, i.e., U+000A, is honoured as a terminator by “<code class="docutils literal notranslate"><span class="pre">.</span></code>”, “<code class="docutils literal notranslate"><span class="pre">$</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">^</span></code>”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uword</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether to use the Unicode definition of word boundaries (see <a class="reference internal" href="other_operations.html#sec-boundaryanalysis"><span class="std std-ref">Analysing Text Boundaries</span></a>), which are quite different from the traditional regex word boundaries</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">error_on_unknown_escapes</span></code></p></td>
<td><p>logical; defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>; whether unrecognised backslash-escaped characters trigger an error; by default, unknown backslash-escaped ASCII letters represent themselves</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">time_limit</span></code></p></td>
<td><p>integer; processing time limit for match operations in ~milliseconds (depends on the CPU speed); 0 for no limit (the default)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stack_limit</span></code></p></td>
<td><p>integer; maximal size, in bytes, of the heap storage available for the matcher’s backtracking stack; setting a limit is desirable if poorly written regexes are expected on input; 0 for no limit (the default)</p></td>
</tr>
</tbody>
</table>
<section id="matching-individual-characters">
<span id="sec-regexindividualchars"></span><h2>Matching Individual Characters<a class="headerlink" href="#matching-individual-characters" title="Permalink to this heading"></a></h2>
<p>We begin by discussing different ways to define character sets. In this
part, determining the length of all matching substrings will be quite
straightforward.</p>
<p>The following characters have special meaning to the regex engine:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">.</span></code>
<code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">|</span></code>
<code class="docutils literal notranslate"><span class="pre">(</span></code>
<code class="docutils literal notranslate"><span class="pre">)</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">{</span></code>
<code class="docutils literal notranslate"><span class="pre">}</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">$</span></code>
<code class="docutils literal notranslate"><span class="pre">*</span></code>
<code class="docutils literal notranslate"><span class="pre">+</span></code>
<code class="docutils literal notranslate"><span class="pre">?</span></code></p>
</div></blockquote>
<p>Any regular expression that doesn’t contain the above behaves like a
fixed pattern:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;spam, eggs, spam, bacon, sausage, and spam&quot;</span><span class="p">,</span> <span class="s">&quot;spam&quot;</span><span class="p">)</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
<p>There are hence 3 occurrences of a pattern that is comprised of 4 code
points, “<code class="docutils literal notranslate"><span class="pre">s</span></code>” followed by “<code class="docutils literal notranslate"><span class="pre">p</span></code>”, then by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”, and ending with “<code class="docutils literal notranslate"><span class="pre">m</span></code>”.</p>
<p>However, this time the case insensitive mode fully supports Unicode
matching<a class="footnote-reference brackets" href="#footequivalent" id="id8">1</a>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_detect_regex</span><span class="p">(</span><span class="s">&quot;groß&quot;</span><span class="p">,</span> <span class="s">&quot;GROSS&quot;</span><span class="p">,</span> <span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] TRUE</span>
</pre></div>
</div>
<p>If we wish to include a special character as part of a regular
expression – so that it is treated literally – we’ll need to escape
it with a backslash, “&quot;. Yet, the backlash itself has a special
meaning to R, see <code class="docutils literal notranslate"><span class="pre">help(&quot;Quotes&quot;)</span></code>. Therefore it needs to be preceded by
another backslash.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;spam...&quot;</span><span class="p">,</span> <span class="s">&quot;\\.&quot;</span><span class="p">)</span>   <span class="c1"># &quot;\\&quot; is a way to input a single \</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
<p>In other words, the R string <code class="docutils literal notranslate"><span class="pre">&quot;\\.&quot;</span></code> is seen by the regex engine as
“<code class="docutils literal notranslate"><span class="pre">\.</span></code>” and interpreted as the dot character (literally). Alternatively,
since R 4.0 we can also input the so-called literal strings like
<code class="docutils literal notranslate"><span class="pre">r&quot;(\.)&quot;</span></code>.</p>
<section id="matching-any-character">
<h3>Matching Any Character<a class="headerlink" href="#matching-any-character" title="Permalink to this heading"></a></h3>
<p>The (unescaped) dot, “<code class="docutils literal notranslate"><span class="pre">.</span></code>”, matches any code point except the newline.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;Spam, ham,\njam, SPAM, eggs, and spam&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;..am&quot;</span><span class="p">,</span> <span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;Spam&quot; &quot; ham&quot; &quot;SPAM&quot; &quot;spam&quot;</span>
</pre></div>
</div>
<p>The above matches non-overlapping length-4 substrings that end with
“<code class="docutils literal notranslate"><span class="pre">am</span></code>”.</p>
<p>The dot’s insensitivity to the newline character is motivated by the
need to maintain compatibility with tools such as <em>grep</em> (when
searching within text files in a line-by-line manner). This behaviour
can be altered by setting the <code class="docutils literal notranslate"><span class="pre">dot_all</span></code> option to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;..am&quot;</span><span class="p">,</span> <span class="n">dot_all</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> <span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;Spam&quot;  &quot; ham&quot;  &quot;\njam&quot; &quot;SPAM&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
</section>
<section id="defining-character-sets">
<h3>Defining Character Sets<a class="headerlink" href="#defining-character-sets" title="Permalink to this heading"></a></h3>
<p>Sets of characters can be introduced by enumerating their members within
a pair of square brackets. For instance, “<code class="docutils literal notranslate"><span class="pre">[abc]</span></code>” denotes the set
${\mathtt{a},\mathtt{b},\mathtt{c}}$ – such a regular expression
matches one (and only one) symbol from this set. Moreover, in:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;[hj]am&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;ham&quot; &quot;jam&quot;</span>
</pre></div>
</div>
<p>the “<code class="docutils literal notranslate"><span class="pre">[hj]am</span></code>” regex matches: “<code class="docutils literal notranslate"><span class="pre">h</span></code>” or “<code class="docutils literal notranslate"><span class="pre">j</span></code>”, followed by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
followed by “<code class="docutils literal notranslate"><span class="pre">m</span></code>”. In other words, <code class="docutils literal notranslate"><span class="pre">&quot;ham&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;jam&quot;</span></code> are the only two
strings that are matched by this pattern (unless matching is done
case-insensitively).</p>
<p>The following characters, if used within square brackets, may be treated
non-literally:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">]</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">-</span></code>
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p>
</div></blockquote>
<p>Therefore, to include them as-is in a character set, the
backslash-escape must be used. For example, “<code class="docutils literal notranslate"><span class="pre">[\[\]\\]</span></code>” matches a
backslash or a square bracket.</p>
</section>
<section id="complementing-sets">
<h3>Complementing Sets<a class="headerlink" href="#complementing-sets" title="Permalink to this heading"></a></h3>
<p>Including “<code class="docutils literal notranslate"><span class="pre">^</span></code>” after the opening square bracket denotes the set
complement. Hence, “<code class="docutils literal notranslate"><span class="pre">[^abc]</span></code>” matches any code point except “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">b</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">c</span></code>”. Here is an example where we seek any substring that
consists of 3 non-spaces.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;Nobody expects the Spanish Inquisition!&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;[^ ][^ ][^ ]&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;Nob&quot; &quot;ody&quot; &quot;exp&quot; &quot;ect&quot; &quot;the&quot; &quot;Spa&quot; &quot;nis&quot; &quot;Inq&quot; &quot;uis&quot; &quot;iti&quot; &quot;on!&quot;</span>
</pre></div>
</div>
</section>
<section id="defining-code-point-ranges">
<h3>Defining Code Point Ranges<a class="headerlink" href="#defining-code-point-ranges" title="Permalink to this heading"></a></h3>
<p>Each Unicode code point can be referenced by its unique numeric
identifier; see <a class="reference internal" href="input_output.html#sec-codepoints"><span class="std std-ref">Dealing with Unicode Code Points</span></a> for more details. For instance, “<code class="docutils literal notranslate"><span class="pre">a</span></code>” is
assigned code U+0061, and “<code class="docutils literal notranslate"><span class="pre">z</span></code>” is mapped to U+007A. In the pre-Unicode
era (mostly with regards to the ASCII codes, ≤ U+007F, representing
English letters, decimal digits, some punctuation characters, and a few
control characters), we were used to relying on specific code ranges;
e.g., “<code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>” denotes the set comprised of all characters with codes
between U+0061 and U+007A, i.e., lowercase letters of the English
(Latin) alphabet.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;In 2020, Gągolewski had fun once.&quot;</span><span class="p">,</span> <span class="s">&quot;[0-9A-Za-z]&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;I&quot; &quot;n&quot; &quot;2&quot; &quot;0&quot; &quot;2&quot; &quot;0&quot; &quot;G&quot; &quot;g&quot; &quot;o&quot; &quot;l&quot; &quot;e&quot; &quot;w&quot; &quot;s&quot; &quot;k&quot; &quot;i&quot; &quot;h&quot; &quot;a&quot; &quot;d&quot;</span>
<span class="c1">## [19] &quot;f&quot; &quot;u&quot; &quot;n&quot; &quot;o&quot; &quot;n&quot; &quot;c&quot; &quot;e&quot;</span>
</pre></div>
</div>
<p>The above pattern denotes a union of 3 code ranges: digits and ASCII
upper- and lowercase letters.</p>
<p>Nowadays, when processing text in natural languages, this notation
should be avoided. Note the missing “<code class="docutils literal notranslate"><span class="pre">ą</span></code>” (Polish “<code class="docutils literal notranslate"><span class="pre">a</span></code>” with
ogonek) in the result.</p>
</section>
<section id="using-predefined-character-sets">
<h3>Using Predefined Character Sets<a class="headerlink" href="#using-predefined-character-sets" title="Permalink to this heading"></a></h3>
<p>Each code point is assigned a unique general category, which can be
thought of as a character’s class, see
<a class="reference external" href="https://unicode.org/reports/tr44/">Unicode Standard Annex #44: {U}nicode Character Database</a>. Sets of characters
from each category can be referred to, amongst others, by using the
“<code class="docutils literal notranslate"><span class="pre">\p{category}</span></code>” (or, equivalently, “<code class="docutils literal notranslate"><span class="pre">[\p{category}]</span></code>”) syntax:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;aąbßÆAĄB你123,.;&#39;! \t-+=[]©←→”„²³¾&quot;</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\p{L}&quot;</span><span class="p">,</span> <span class="s">&quot;\\p{Ll}&quot;</span><span class="p">,</span> <span class="s">&quot;\\p{Lu}&quot;</span><span class="p">,</span> <span class="s">&quot;\\p{N}&quot;</span><span class="p">,</span> <span class="s">&quot;\\p{P}&quot;</span><span class="p">,</span> <span class="s">&quot;\\p{S}&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="c1">## $`\\p{L}`</span>
<span class="c1">## [1] &quot;a&quot;  &quot;ą&quot;  &quot;b&quot;  &quot;ß&quot;  &quot;Æ&quot;  &quot;A&quot;  &quot;Ą&quot;  &quot;B&quot;  &quot;你&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{Ll}`</span>
<span class="c1">## [1] &quot;a&quot; &quot;ą&quot; &quot;b&quot; &quot;ß&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{Lu}`</span>
<span class="c1">## [1] &quot;Æ&quot; &quot;A&quot; &quot;Ą&quot; &quot;B&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{N}`</span>
<span class="c1">## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;²&quot; &quot;³&quot; &quot;¾&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{P}`</span>
<span class="c1">##  [1] &quot;,&quot; &quot;.&quot; &quot;;&quot; &quot;&#39;&quot; &quot;!&quot; &quot;-&quot; &quot;[&quot; &quot;]&quot; &quot;”&quot; &quot;„&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\p{S}`</span>
<span class="c1">## [1] &quot;+&quot; &quot;=&quot; &quot;©&quot; &quot;←&quot; &quot;→&quot;</span>
</pre></div>
</div>
<p>The above yield a match to: arbitrary letters, lowercase letters,
uppercase letters, numbers, punctuation marks, and symbols,
respectively.</p>
<p>Characters’ binary properties and scripts can also be referenced in a
similar manner. Some other noteworthy classes include:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\w&quot;</span><span class="p">,</span> <span class="s">&quot;\\d&quot;</span><span class="p">,</span> <span class="s">&quot;\\s&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="c1">## $`\\w`</span>
<span class="c1">##  [1] &quot;a&quot;  &quot;ą&quot;  &quot;b&quot;  &quot;ß&quot;  &quot;Æ&quot;  &quot;A&quot;  &quot;Ą&quot;  &quot;B&quot;  &quot;你&quot; &quot;1&quot;  &quot;2&quot;  &quot;3&quot; </span>
<span class="c1">## </span>
<span class="c1">## $`\\d`</span>
<span class="c1">## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</span>
<span class="c1">## </span>
<span class="c1">## $`\\s`</span>
<span class="c1">## [1] &quot; &quot;  &quot;\t&quot;</span>
</pre></div>
</div>
<p>These give: word characters, decimal digits (”<code class="docutils literal notranslate"><span class="pre">\p{Nd}</span></code>”), and spaces
(”<code class="docutils literal notranslate"><span class="pre">[\t\n\f\r\p{Z}]</span></code>”), in this order.</p>
<p>Moreover, e.g., the upper-cased “<code class="docutils literal notranslate"><span class="pre">\P{category}</span></code>” and “<code class="docutils literal notranslate"><span class="pre">\W</span></code>” are
equivalent to “<code class="docutils literal notranslate"><span class="pre">[^\p{category}]</span></code>” and “<code class="docutils literal notranslate"><span class="pre">[^\w]</span></code>”, respectively, i.e.,
denote their complements.</p>
</section>
<section id="avoiding-posix-classes">
<h3>Avoiding POSIX Classes<a class="headerlink" href="#avoiding-posix-classes" title="Permalink to this heading"></a></h3>
<p>The use of the POSIX-like character classes should be avoided because
they are generally not well-defined.</p>
<p>In particular, in POSIX-like regex engines, “<code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code>” stands for the
character class corresponding to the <code class="docutils literal notranslate"><span class="pre">ispunct()</span></code> function in C (see
“<code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">3</span> <span class="pre">ispunct</span></code>” on Unix-like systems). According to ISO/IEC 9899:1990
(ISO C90), <code class="docutils literal notranslate"><span class="pre">ispunct()</span></code> tests for any printing character except for the
space or a character for which <code class="docutils literal notranslate"><span class="pre">isalnum()</span></code> is true.</p>
<p>Base R with <em>PCRE</em> yields on the current author’s machine:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;,./|\\&lt;&gt;?;:&#39;\&quot;[]{}-=_+()*&amp;^%$€#@!`~×‒„”&quot;</span>
<span class="nf">regmatches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nf">gregexpr</span><span class="p">(</span><span class="s">&quot;[[:punct:]]&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">perl</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">))</span>  <span class="c1"># base R</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;,&quot;  &quot;.&quot;  &quot;/&quot;  &quot;|&quot;  &quot;\\&quot; &quot;&lt;&quot;  &quot;&gt;&quot;  &quot;?&quot;  &quot;;&quot;  &quot;:&quot;  &quot;&#39;&quot;  &quot;\&quot;&quot; &quot;[&quot;  &quot;]&quot; </span>
<span class="c1">## [15] &quot;{&quot;  &quot;}&quot;  &quot;-&quot;  &quot;=&quot;  &quot;_&quot;  &quot;+&quot;  &quot;(&quot;  &quot;)&quot;  &quot;*&quot;  &quot;&amp;&quot;  &quot;^&quot;  &quot;%&quot;  &quot;$&quot;  &quot;#&quot; </span>
<span class="c1">## [29] &quot;@&quot;  &quot;!&quot;  &quot;`&quot;  &quot;~&quot;</span>
</pre></div>
</div>
<p>However, the details of the characters’ belongingness to this class
depend on the current locale. Therefore, the reader might obtain
different results when calling the above.</p>
<p><em>ICU</em>, on the other hand, always gives:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;[[:punct:]]&quot;</span><span class="p">)</span>    <span class="c1"># equivalently: \p{P}</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;,&quot;  &quot;.&quot;  &quot;/&quot;  &quot;\\&quot; &quot;?&quot;  &quot;;&quot;  &quot;:&quot;  &quot;&#39;&quot;  &quot;\&quot;&quot; &quot;[&quot;  &quot;]&quot;  &quot;{&quot;  &quot;}&quot;  &quot;-&quot; </span>
<span class="c1">## [15] &quot;_&quot;  &quot;(&quot;  &quot;)&quot;  &quot;*&quot;  &quot;&amp;&quot;  &quot;%&quot;  &quot;#&quot;  &quot;@&quot;  &quot;!&quot;  &quot;‒&quot;  &quot;„&quot;  &quot;”&quot;</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code> is merely a synonym for <code class="docutils literal notranslate"><span class="pre">\p{P}</span></code>. Further, <code class="docutils literal notranslate"><span class="pre">\p{S}</span></code>
captures symbols:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;\\p{S}&quot;</span><span class="p">)</span>         <span class="c1"># symbols</span>
<span class="c1">## [[1]]</span>
<span class="c1">##  [1] &quot;|&quot; &quot;&lt;&quot; &quot;&gt;&quot; &quot;=&quot; &quot;+&quot; &quot;^&quot; &quot;$&quot; &quot;€&quot; &quot;`&quot; &quot;~&quot; &quot;×&quot;</span>
</pre></div>
</div>
<p>We strongly recommend, wherever possible, the use of the portable
“<code class="docutils literal notranslate"><span class="pre">[\p{P}\p{S}]</span></code>” as an alternative to the <em>PCRE</em>’s “<code class="docutils literal notranslate"><span class="pre">[:punct:]</span></code>”.</p>
</section>
</section>
<section id="alternating-and-grouping-subexpressions">
<h2>Alternating and Grouping Subexpressions<a class="headerlink" href="#alternating-and-grouping-subexpressions" title="Permalink to this heading"></a></h2>
<section id="alternation-operator">
<h3>Alternation Operator<a class="headerlink" href="#alternation-operator" title="Permalink to this heading"></a></h3>
<p>The alternation operator, “<code class="docutils literal notranslate"><span class="pre">|</span></code>”, matches either its left or its right
branch, for instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;spam, egg, ham, jam, algae, and an amalgam of spam, all al dente&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;spam|ham&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>“<code class="docutils literal notranslate"><span class="pre">|</span></code>” has very low precedence. Therefore, if we wish to introduce an
alternative of subexpressions, we need to group them, e.g., between
round brackets. For instance, “<code class="docutils literal notranslate"><span class="pre">(sp|h)am</span></code>” matches either “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”
or “<code class="docutils literal notranslate"><span class="pre">ham</span></code>”.</p>
<p>Note that this has the side-effect of creating new capturing groups;
see <a class="reference internal" href="#sec-capturing"><span class="std std-ref">Capture Groups and References Thereto</span></a>.</p>
</section>
<section id="grouping-subexpressions">
<h3>Grouping Subexpressions<a class="headerlink" href="#grouping-subexpressions" title="Permalink to this heading"></a></h3>
<p>Also, matching is always done left-to-right, on a first-come,
first-served basis. So, if the left branch is a subset of the right
one, the latter will never be matched. In particular,
“<code class="docutils literal notranslate"><span class="pre">(al|alga|algae)</span></code>” can only match “<code class="docutils literal notranslate"><span class="pre">al</span></code>”. To fix this, we can write
“<code class="docutils literal notranslate"><span class="pre">(algae|alga|al)</span></code>”.</p>
</section>
<section id="non-grouping-parentheses">
<h3>Non-grouping Parentheses<a class="headerlink" href="#non-grouping-parentheses" title="Permalink to this heading"></a></h3>
<p>Some parenthesised subexpressions – those in which the opening bracket
is followed by the question mark – have a distinct meaning. In
particular, “<code class="docutils literal notranslate"><span class="pre">(?#...)</span></code>” denotes a free-format comment that is ignored by
the regex parser:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
  <span class="s">&quot;(?# match &#39;sp&#39; or &#39;h&#39;)(sp|h)(?# and &#39;am&#39;)am|(?# or match &#39;egg&#39;)egg&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;egg&quot;  &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>Nevertheless, constructing more sophisticated regexes by concatenating
subfragments thereof may sometimes be more readable:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
  <span class="nf">stri_join</span><span class="p">(</span>
      <span class="s">&quot;(sp|h)&quot;</span><span class="p">,</span>   <span class="c1"># match either &#39;sp&#39; or &#39;h&#39;</span>
      <span class="s">&quot;am&quot;</span><span class="p">,</span>       <span class="c1"># followed by &#39;am&#39;</span>
    <span class="s">&quot;|&quot;</span><span class="p">,</span>            <span class="c1"># ... or ...</span>
      <span class="s">&quot;egg&quot;</span>       <span class="c1"># just match &#39;egg&#39;</span>
<span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;egg&quot;  &quot;ham&quot;  &quot;spam&quot;</span>
</pre></div>
</div>
<p>What is more, e.g., “<code class="docutils literal notranslate"><span class="pre">(?i)</span></code>” enables the <code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code> mode.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_regex</span><span class="p">(</span><span class="s">&quot;Spam spam SPAMITY spAm&quot;</span><span class="p">,</span> <span class="s">&quot;(?i)spam&quot;</span><span class="p">)</span>
<span class="c1">## [1] 4</span>
</pre></div>
</div>
</section>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this heading"></a></h2>
<p>More often than not, a variable number of instances of the same
subexpression needs to be captured, or its presence should be
optional. This can be achieved by means of the following quantifiers:</p>
<ul class="simple">
<li><p>“<code class="docutils literal notranslate"><span class="pre">?</span></code>” matches 0 or 1 times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">*</span></code>” matches 0 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">+</span></code>” matches 1 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,m}</span></code>” matches between <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,}</span></code>” matches at least <code class="docutils literal notranslate"><span class="pre">n</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n}</span></code>” matches exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p></li>
</ul>
<p>These operators are applied to the preceding atoms. For example, “<code class="docutils literal notranslate"><span class="pre">ba+</span></code>”
captures <code class="docutils literal notranslate"><span class="pre">&quot;ba&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baa&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baaa&quot;</span></code>, etc., but neither <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code> alone
nor <code class="docutils literal notranslate"><span class="pre">&quot;bababa&quot;</span></code> altogether.</p>
<p>By default, the quantifiers are greedy – they match the repeated
subexpression as many times as possible. The “<code class="docutils literal notranslate"><span class="pre">?</span></code>” suffix (hence,
quantifiers such as “<code class="docutils literal notranslate"><span class="pre">??</span></code>”, “<code class="docutils literal notranslate"><span class="pre">*?</span></code>”, “<code class="docutils literal notranslate"><span class="pre">+?</span></code>”, and so forth) tries with as
few occurrences as possible (to obtain a match still).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;sp(AM)(maps)(SP)am&quot;</span>
<span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
  <span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\(.+\\)&quot;</span><span class="p">,</span>    <span class="c1"># [[1]] greedy</span>
    <span class="s">&quot;\\(.+?\\)&quot;</span><span class="p">,</span>   <span class="c1"># [[2]] lazy</span>
    <span class="s">&quot;\\([^)]+\\)&quot;</span>  <span class="c1"># [[3]] greedy (but clever)</span>
<span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;(AM)(maps)(SP)&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;(AM)&quot;   &quot;(maps)&quot; &quot;(SP)&quot;  </span>
<span class="c1">## </span>
<span class="c1">## [[3]]</span>
<span class="c1">## [1] &quot;(AM)&quot;   &quot;(maps)&quot; &quot;(SP)&quot;</span>
</pre></div>
</div>
<p>The first regex is greedy: it matches an opening bracket, then as many
characters as possible (including “<code class="docutils literal notranslate"><span class="pre">)</span></code>”) that are followed by a closing
bracket. The two other patterns terminate as soon as the first closing
bracket is found.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_first_regex</span><span class="p">(</span><span class="s">&quot;spamamamnomnomnomammmmmmmmm&quot;</span><span class="p">,</span>
  <span class="nf">c</span><span class="p">(</span><span class="s">&quot;sp(am|nom)+&quot;</span><span class="p">,</span>             <span class="s">&quot;sp(am|nom)+?&quot;</span><span class="p">,</span>
    <span class="s">&quot;sp(am|nom)+?m*&quot;</span><span class="p">,</span>          <span class="s">&quot;sp(am|nom)+?m+&quot;</span><span class="p">))</span>
<span class="c1">## [1] &quot;spamamamnomnomnomam&quot;         &quot;spam&quot;                       </span>
<span class="c1">## [3] &quot;spam&quot;                        &quot;spamamamnomnomnomammmmmmmmm&quot;</span>
</pre></div>
</div>
<p>Let’s stress that the quantifier is applied to the subexpression that
stands directly before it. Grouping parentheses can be used in case they
are needed.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;12, 34.5, 678.901234, 37...629, ...&quot;</span><span class="p">,</span>
  <span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\d+\\.\\d+&quot;</span><span class="p">,</span> <span class="s">&quot;\\d+(\\.\\d+)?&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;34.5&quot;       &quot;678.901234&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;12&quot;         &quot;34.5&quot;       &quot;678.901234&quot; &quot;37&quot;         &quot;629&quot;</span>
</pre></div>
</div>
<p>Here, the first regex matches digits, a dot, and another series of
digits. The second one finds digits that are possibly (but not
necessarily) followed by a dot and a digit sequence.</p>
<section id="performance-notes">
<h3>Performance Notes<a class="headerlink" href="#performance-notes" title="Permalink to this heading"></a></h3>
<p><em>ICU</em>, just like <em>PCRE</em>, uses a nondeterministic finite automaton-type
algorithm. Hence, due to backtracking, some ill-defined regexes can lead
to exponential matching times (e.g., “<code class="docutils literal notranslate"><span class="pre">(a+)+b</span></code>” applied on
<code class="docutils literal notranslate"><span class="pre">&quot;aaaa...aaaaac&quot;</span></code>). If such patterns are expected, setting the
<code class="docutils literal notranslate"><span class="pre">time_limit</span></code> or <code class="docutils literal notranslate"><span class="pre">stack_limit</span></code> option is recommended.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">system.time</span><span class="p">(</span><span class="nf">tryCatch</span><span class="p">({</span>
  <span class="nf">stri_detect_regex</span><span class="p">(</span><span class="s">&quot;a&quot;</span> <span class="o">%s*%</span> <span class="m">1000</span> <span class="o">%s+%</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;(a+)+b&quot;</span><span class="p">,</span> <span class="n">time_limit</span><span class="o">=</span><span class="m">1e5</span><span class="p">)</span>
<span class="p">},</span> <span class="n">error</span><span class="o">=</span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="nf">cat</span><span class="p">(</span><span class="s">&quot;stopped.&quot;</span><span class="p">)))</span>
<span class="c1">## stopped.</span>
<span class="c1">##    user  system elapsed </span>
<span class="c1">##  18.147   0.001  18.148</span>
</pre></div>
</div>
<p>Nevertheless, oftentimes such regexes can be naturally reformulated to
fix the underlying issue. The <em>ICU</em> User Guide on Regular Expressions
also recommends using possessive quantifiers (”<code class="docutils literal notranslate"><span class="pre">?+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">*+</span></code>”, “<code class="docutils literal notranslate"><span class="pre">++</span></code>”,
and so on), which match as many times as possible but, contrary to the
plain-greedy ones, never backtrack when they happen to consume too much
data.</p>
<p>See also the documentation of
the <a class="reference external" href="https://github.com/qinwf/re2r"><em>re2r</em></a>
and <a class="reference external" href="https://github.com/girishji/re2/"><em>re2</em></a>
(wrappers around the <a class="reference external" href="https://github.com/google/re2"><em>RE2</em></a>
library) packages and the references therein for a discussion.</p>
</section>
</section>
<section id="capture-groups-and-references-thereto">
<span id="sec-capturing"></span><h2>Capture Groups and References Thereto<a class="headerlink" href="#capture-groups-and-references-thereto" title="Permalink to this heading"></a></h2>
<p>Round-bracketed subexpressions carry one additional characteristic: they
form the so-called capture groups that can be extracted separately or be
referred to in other parts of the same regex.</p>
<section id="extracting-capture-group-matches">
<h3>Extracting Capture Group Matches<a class="headerlink" href="#extracting-capture-group-matches" title="Permalink to this heading"></a></h3>
<p>The above is evident when we use the versions of <code class="docutils literal notranslate"><span class="pre">stri_extract()</span></code> that
are sensitive to the presence of capture groups:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="s">&quot;name=&#39;Sir Launcelot&#39;, quest=&#39;Seek the Grail&#39;, favecolour=&#39;blue&#39;&quot;</span>
<span class="nf">stri_match_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##      [,1]                     [,2]         [,3]            </span>
<span class="c1">## [1,] &quot;name=&#39;Sir Launcelot&#39;&quot;   &quot;name&quot;       &quot;Sir Launcelot&quot; </span>
<span class="c1">## [2,] &quot;quest=&#39;Seek the Grail&#39;&quot; &quot;quest&quot;      &quot;Seek the Grail&quot;</span>
<span class="c1">## [3,] &quot;favecolour=&#39;blue&#39;&quot;      &quot;favecolour&quot; &quot;blue&quot;</span>
</pre></div>
</div>
<p>The findings are presented in a matrix form. The first column gives the
complete matches, the second column stores the matches to the first
capture group, and so forth.</p>
<p>If we just need the grouping part of “<code class="docutils literal notranslate"><span class="pre">(...)</span></code>”, i.e., without the
capturing feature, “<code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>” can be applied. Also, named capture
groups defined like “<code class="docutils literal notranslate"><span class="pre">(?&lt;name&gt;...)</span></code>” are fully supported since version
1.7.1 of our package (for historical notes see <span id="id9">[<a class="reference internal" href="../z_bibliography.html#id31" title="T.D. Hocking. Comparing namedCapture with other R packages for regular expressions. The R Journal, 11/2:328–346, 2019.">Hoc19</a>]</span>).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_match_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(?:\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##                               value           </span>
<span class="c1">## [1,] &quot;name=&#39;Sir Launcelot&#39;&quot;   &quot;Sir Launcelot&quot; </span>
<span class="c1">## [2,] &quot;quest=&#39;Seek the Grail&#39;&quot; &quot;Seek the Grail&quot;</span>
<span class="c1">## [3,] &quot;favecolour=&#39;blue&#39;&quot;      &quot;blue&quot;</span>
</pre></div>
</div>
</section>
<section id="locating-capture-group-matches">
<h3>Locating Capture Group Matches<a class="headerlink" href="#locating-capture-group-matches" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">capture_groups</span></code> attribute in <code class="docutils literal notranslate"><span class="pre">stri_locate__regex</span></code> enables us to
pinpoint the matches to the parenthesised subexpressions as well:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_locate_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(?&lt;key&gt;\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">,</span>
  <span class="n">capture_groups</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span> <span class="n">get_length</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     1     20</span>
<span class="c1">## [2,]    23     22</span>
<span class="c1">## [3,]    47     17</span>
<span class="c1">## attr(,&quot;capture_groups&quot;)</span>
<span class="c1">## attr(,&quot;capture_groups&quot;)$key</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     1      4</span>
<span class="c1">## [2,]    23      5</span>
<span class="c1">## [3,]    47     10</span>
<span class="c1">## </span>
<span class="c1">## attr(,&quot;capture_groups&quot;)$value</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     7     13</span>
<span class="c1">## [2,]    30     14</span>
<span class="c1">## [3,]    59      4</span>
</pre></div>
</div>
<p>Note that each item in the resulting list is equipped with a
<code class="docutils literal notranslate"><span class="pre">&quot;capture_groups&quot;</span></code> attribute. For instance,
<code class="docutils literal notranslate"><span class="pre">attr(result[[1]],</span> <span class="pre">&quot;capture_groups&quot;)[[2]]</span></code> extracts the locations of the
matches to the 2nd capture group in the first input string.</p>
</section>
<section id="replacing-with-capture-group-matches">
<h3>Replacing with Capture Group Matches<a class="headerlink" href="#replacing-with-capture-group-matches" title="Permalink to this heading"></a></h3>
<p>Matches to particular capture groups can be recalled in replacement
strings when using <code class="docutils literal notranslate"><span class="pre">stri_replace()</span></code>. Here, the match in its entirety is
denoted with “<code class="docutils literal notranslate"><span class="pre">$0</span></code>”, then “<code class="docutils literal notranslate"><span class="pre">$1</span></code>” stores whatever was caught by the first
capture group, “<code class="docutils literal notranslate"><span class="pre">$2</span></code>” is the match to the second capture group, etc.
Moreover, “<code class="docutils literal notranslate"><span class="pre">\$</span></code>” gives the dollar-sign.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_replace_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;$2 is a $1&quot;</span><span class="p">)</span>
<span class="c1">## [1] &quot;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&quot;</span>
</pre></div>
</div>
<p>Named capture groups can be referred to too:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_replace_all_regex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(?&lt;key&gt;\\w+)=&#39;(?&lt;value&gt;.+?)&#39;&quot;</span><span class="p">,</span>
  <span class="s">&quot;${value} is a ${key}&quot;</span><span class="p">)</span>
<span class="c1">## [1] &quot;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&quot;</span>
</pre></div>
</div>
</section>
<section id="back-referencing">
<h3>Back-Referencing<a class="headerlink" href="#back-referencing" title="Permalink to this heading"></a></h3>
<p>Matches to capture groups can also be part of the regexes themselves.
For example, “<code class="docutils literal notranslate"><span class="pre">\1</span></code>” denotes whatever has been consumed by the first
capture group.</p>
<p>Even though, in general, parsing HTML code with regexes is not
recommended, let’s consider the following examples:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;eggs&lt;/code&gt;&quot;</span><span class="p">,</span>
  <span class="nf">c</span><span class="p">(</span><span class="s">&quot;&lt;[a-z]+&gt;.*?&lt;/[a-z]+&gt;&quot;</span><span class="p">,</span> <span class="s">&quot;&lt;([a-z]+)&gt;.*?&lt;/\\1&gt;&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&quot; &quot;&lt;code&gt;eggs&lt;/code&gt;&quot;    </span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&quot; &quot;&lt;code&gt;eggs&lt;/code&gt;&quot;</span>
</pre></div>
</div>
<p>The second regex guarantees that the match will include all characters
between the opening <code class="docutils literal notranslate"><span class="pre">&lt;tag&gt;</span></code> and the corresponding (not: any) closing
<code class="docutils literal notranslate"><span class="pre">&lt;/tag&gt;</span></code>. Named capture groups can be referenced using the <code class="docutils literal notranslate"><span class="pre">\k&lt;name&gt;</span></code>
syntax (the angle brackets are part of the token), as in, e.g.,
“<code class="docutils literal notranslate"><span class="pre">&lt;(?&lt;tagname&gt;[a-z]+)&gt;.*?&lt;/\k&lt;tagname&gt;&gt;</span></code>”.</p>
</section>
</section>
<section id="anchoring">
<h2>Anchoring<a class="headerlink" href="#anchoring" title="Permalink to this heading"></a></h2>
<p>Lastly, let’s mention how to match a pattern at a given abstract
position within a string.</p>
<section id="matching-at-the-beginning-or-end-of-a-string">
<h3>Matching at the Beginning or End of a String<a class="headerlink" href="#matching-at-the-beginning-or-end-of-a-string" title="Permalink to this heading"></a></h3>
<p>“<code class="docutils literal notranslate"><span class="pre">^</span></code>” and “<code class="docutils literal notranslate"><span class="pre">$</span></code>” match, respectively, the start and the end of the string (or
each line within a string, if the <code class="docutils literal notranslate"><span class="pre">multi_line</span></code> option is set to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam egg&quot;</span><span class="p">,</span> <span class="s">&quot;bacon spam&quot;</span><span class="p">,</span> <span class="s">&quot;spam&quot;</span><span class="p">,</span> <span class="s">&quot;egg spam bacon&quot;</span><span class="p">,</span> <span class="s">&quot;sausage&quot;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">,</span> <span class="s">&quot;^spam&quot;</span><span class="p">,</span> <span class="s">&quot;spam$&quot;</span><span class="p">,</span> <span class="s">&quot;spam$|^spam&quot;</span><span class="p">,</span> <span class="s">&quot;^spam$&quot;</span><span class="p">)</span>
<span class="nf">structure</span><span class="p">(</span><span class="nf">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">stri_detect_regex</span><span class="p">),</span> <span class="n">dimnames</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
<span class="c1">##                 spam ^spam spam$ spam$|^spam ^spam$</span>
<span class="c1">## spam egg        TRUE  TRUE FALSE        TRUE  FALSE</span>
<span class="c1">## bacon spam      TRUE FALSE  TRUE        TRUE  FALSE</span>
<span class="c1">## spam            TRUE  TRUE  TRUE        TRUE   TRUE</span>
<span class="c1">## egg spam bacon  TRUE FALSE FALSE       FALSE  FALSE</span>
<span class="c1">## sausage        FALSE FALSE FALSE       FALSE  FALSE</span>
</pre></div>
</div>
<p>The 5 regular expressions match “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”, respectively, anywhere within
the string, at the beginning, at the end, at the beginning or end, and
in strings that are equal to the pattern itself.</p>
</section>
<section id="matching-at-word-boundaries">
<h3>Matching at Word Boundaries<a class="headerlink" href="#matching-at-word-boundaries" title="Permalink to this heading"></a></h3>
<p>Furthermore, “<code class="docutils literal notranslate"><span class="pre">\b</span></code>” matches at a “word boundary”, e.g., near spaces,
punctuation marks, or at the start/end of a string (i.e., wherever there
is a transition between a word, “<code class="docutils literal notranslate"><span class="pre">\w</span></code>”, and a non-word character,
“<code class="docutils literal notranslate"><span class="pre">\W</span></code>”, or vice versa).</p>
<p>In the following example, we match all stand-alone numbers
(this regular expression is provided for didactic purposes only):</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;12, 34.5, J23, 37.629cm&quot;</span><span class="p">,</span> <span class="s">&quot;\\b\\d+(\\.\\d+)?+\\b&quot;</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;12&quot;   &quot;34.5&quot;</span>
</pre></div>
</div>
<p>Note the possessive quantifier, “<code class="docutils literal notranslate"><span class="pre">?+</span></code>”: try matching a dot and a
sequence of digits, and if it’s present but not followed by a word
boundary, do not retry by matching a word boundary only.</p>
</section>
<section id="looking-behind-and-ahead">
<h3>Looking Behind and Ahead<a class="headerlink" href="#looking-behind-and-ahead" title="Permalink to this heading"></a></h3>
<p>There are also ways to guarantee that a pattern occurrence begins or
ends with a match to some subexpression: “<code class="docutils literal notranslate"><span class="pre">(?&lt;=...)...</span></code>” is the
so-called look-behind, whereas “<code class="docutils literal notranslate"><span class="pre">...(?=...)</span></code>” denotes the look-ahead.
Moreover, “<code class="docutils literal notranslate"><span class="pre">(?&lt;!...)...</span></code>” and “<code class="docutils literal notranslate"><span class="pre">...(?!...)</span></code>” are their negated
(“negative look-behind/ahead”) versions.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_all_regex</span><span class="p">(</span><span class="s">&quot;I like spam, spam, eggs, and spam.&quot;</span><span class="p">,</span>
  <span class="nf">c</span><span class="p">(</span><span class="s">&quot;\\w+(?=[,.])&quot;</span><span class="p">,</span> <span class="s">&quot;\\w++(?![,.])&quot;</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;spam&quot; &quot;spam&quot; &quot;eggs&quot; &quot;spam&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;I&quot;    &quot;like&quot; &quot;and&quot;</span>
</pre></div>
</div>
<p>The first regex captures words that end with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” or “<code class="docutils literal notranslate"><span class="pre">.</span></code>”. The second
one matches words that end neither with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” nor “<code class="docutils literal notranslate"><span class="pre">.</span></code>”.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="footequivalent"><span class="brackets"><a class="fn-backref" href="#id8">1</a></span></dt>
<dd><p>This does not mean, though, that it considers canonically
equivalent strings as equal, see <a class="reference internal" href="collation.html#sec-equivalence"><span class="std std-ref">Testing String Equivalence</span></a> for
discussion and a workaround.</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="codepoint_comparing.html" class="btn btn-neutral float-left" title="Code-Pointwise Comparing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="collation.html" class="btn btn-neutral float-right" title="Collation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2023, Marek Gagolewski.
      <span class="lastupdated">Last updated on 2023-01-18T09:23:44+1100.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>