<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Regular Expressions" href="regular_expressions.html" /><link rel="prev" title="Basic String Operations" href="basic_operations.html" />
        <link rel="canonical" href="https://stringi.gagolewski.com/weave/codepoint_comparing.html" />

    <!-- Generated with Sphinx 7.2.5 and Furo 2023.08.19 -->
        <title>Code-Pointwise Comparing - R Package stringi</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=dd03ec4f" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  --color-brand-primary: red;
  --color-brand-content: #CC3333;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  --color-brand-primary: #ff2b53;
  --color-brand-content: #dd3333;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  --color-brand-primary: #ff2b53;
  --color-brand-content: #dd3333;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">R Package stringi</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
<div class="sidebar-logo-container">
  <a class="sidebar-brand" href="../index.html"><img class="sidebar-logo" src="https://www.gagolewski.com/_static/img/stringi.png" alt="Logo"/></a>
</div>

<span class="sidebar-brand-text">
<a class="sidebar-brand" href="../index.html">stringi</a>
</span>
<div class="sidebar-brand">
1.7.12
</div>
<form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">stringi</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing <em>stringi</em></a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi">Source Code (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/stringi/issues">Bug Tracker and Feature Suggestions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cran.r-project.org/package=stringi">CRAN Entry</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="design_principles.html">General Design Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_operations.html">Basic String Operations</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Code-Pointwise Comparing</a></li>
<li class="toctree-l1"><a class="reference internal" href="regular_expressions.html">Regular Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="collation.html">Collation</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_operations.html">Other Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_output.html">Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html">Example Use Case: Data Preparation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../rapi.html">R Package <em>stringi</em> Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of R Package stringi Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_arguments.html">about_arguments:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_encoding.html">about_encoding:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_locale.html">about_locale:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_boundaries.html">about_search_boundaries:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_charclass.html">about_search_charclass:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_coll.html">about_search_coll:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_fixed.html">about_search_fixed:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search_regex.html">about_search_regex:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_search.html">about_search: String Searching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/about_stringi.html">about_stringi: Fast and Portable Character String Processing in R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_add.html">operator_add: Concatenate Two Character Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_compare.html">operator_compare: Compare Strings with or without Collation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/operator_dollar.html">operator_dollar: as a Binary Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_compare.html">stri_compare: Compare Strings with or without Collation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_count_boundaries.html">stri_count_boundaries: Count the Number of Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_count.html">stri_count: Count the Number of Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_add.html">stri_datetime_add: Date and Time Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_create.html">stri_datetime_create: Create a Date-Time Object</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_fields.html">stri_datetime_fields: Get Values for Date and Time Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_format.html">stri_datetime_format: Date and Time Formatting and Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_fstr.html">stri_datetime_fstr: -Style Format Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_now.html">stri_datetime_now: Get Current Date and Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_datetime_symbols.html">stri_datetime_symbols: List Localizable Date-Time Formatting Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_detect.html">stri_detect: Detect Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_dup.html">stri_dup: Duplicate Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_duplicated.html">stri_duplicated: Determine Duplicated Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_detect.html">stri_enc_detect: Detect Character Set and Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_detect2.html">stri_enc_detect2: [DEPRECATED] Detect Locale-Sensitive Character Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_fromutf32.html">stri_enc_fromutf32: Convert From UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_info.html">stri_enc_info: Query a Character Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isascii.html">stri_enc_isascii: Check If a Data Stream Is Possibly in ASCII</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isutf16.html">stri_enc_isutf16: Check If a Data Stream Is Possibly in UTF-16 or UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_isutf8.html">stri_enc_isutf8: Check If a Data Stream Is Possibly in UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_list.html">stri_enc_list: List Known Character Encodings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_mark.html">stri_enc_mark: Get Declared Encodings of Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_set.html">stri_enc_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toascii.html">stri_enc_toascii: Convert To ASCII</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_tonative.html">stri_enc_tonative: Convert Strings To Native Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toutf32.html">stri_enc_toutf32: Convert Strings To UTF-32</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_enc_toutf8.html">stri_enc_toutf8: Convert Strings To UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_encode.html">stri_encode: Convert Strings Between Given Encodings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_escape_unicode.html">stri_escape_unicode: Escape Unicode Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_extract_boundaries.html">stri_extract_boundaries: Extract Data Between Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_extract.html">stri_extract: Extract Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_flatten.html">stri_flatten: Flatten a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_info.html">stri_info:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_isempty.html">stri_isempty: Determine if a String is of Length Zero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_join_list.html">stri_join_list: Concatenate Strings in a List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_join.html">stri_join: Concatenate Character Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_length.html">stri_length: Count the Number of Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_list2matrix.html">stri_list2matrix: Convert a List to a Character Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_info.html">stri_locale_info: Query Given Locale</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_list.html">stri_locale_list: List Available Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locale_set.html">stri_locale_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locate_boundaries.html">stri_locate_boundaries: Locate Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_locate.html">stri_locate: Locate Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_match.html">stri_match: Extract Regex Pattern Matches, Together with Capture Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_na2empty.html">stri_na2empty: Replace NAs with Empty Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_numbytes.html">stri_numbytes: Count the Number of Bytes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_brkiter.html">stri_opts_brkiter: Generate a List with BreakIterator Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_collator.html">stri_opts_collator: Generate a List with Collator Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_fixed.html">stri_opts_fixed: Generate a List with Fixed Pattern Search Engine’s Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_opts_regex.html">stri_opts_regex: Generate a List with Regex Matcher Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_order.html">stri_order: Ordering Permutation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_pad.html">stri_pad: Pad (Center/Left/Right Align) a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_lipsum.html">stri_rand_lipsum: A Lorem Ipsum Generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_shuffle.html">stri_rand_shuffle: Randomly Shuffle Code Points in Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rand_strings.html">stri_rand_strings: Generate Random Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_rank.html">stri_rank: Ranking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_read_lines.html">stri_read_lines: Read Text Lines from a Text File</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_read_raw.html">stri_read_raw: Read Text File as Raw</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_remove_empty.html">stri_remove_empty: Remove All Empty Strings from a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace_na.html">stri_replace_na: Replace Missing Values in a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace_rstr.html">stri_replace_rstr: Convert gsub-Style Replacement Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_replace.html">stri_replace: Replace Pattern Occurrences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_reverse.html">stri_reverse: Reverse Each String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sort_key.html">stri_sort_key: Sort Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sort.html">stri_sort: String Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split_boundaries.html">stri_split_boundaries: Split a String at Text Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split_lines.html">stri_split_lines: Split a String Into Text Lines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_split.html">stri_split: Split a String By Pattern Matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sprintf.html">stri_sprintf: Format Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_startsendswith.html">stri_startsendswith: Determine if the Start or End of a String Matches a Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_stats_general.html">stri_stats_general: General Statistics for a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_stats_latex.html">stri_stats_latex: Statistics for a Character Vector Containing LaTeX Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sub_all.html">stri_sub_all: Extract or Replace Multiple Substrings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_sub.html">stri_sub: Extract a Substring From or Replace a Substring In a Character Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_subset.html">stri_subset: Select Elements that Match a Given Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_info.html">stri_timezone_info: Query a Given Time Zone</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_list.html">stri_timezone_list: List Available Time Zone Identifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_timezone_set.html">stri_timezone_set:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_casemap.html">stri_trans_casemap: Transform Strings with Case Mapping or Folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_char.html">stri_trans_char: Translate Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_general.html">stri_trans_general: General Text Transforms, Including Transliteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_list.html">stri_trans_list: List Available Text Transforms and Transliterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trans_nf.html">stri_trans_nf: Perform or Check For Unicode Normalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_trim.html">stri_trim: Trim Characters from the Left and/or Right Side of a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_unescape_unicode.html">stri_unescape_unicode: Un-escape All Escape Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_unique.html">stri_unique: Extract Unique Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_width.html">stri_width: Determine the Width of Code Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_wrap.html">stri_wrap: Word Wrap Text to Format Paragraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapi/stri_write_lines.html">stri_write_lines: Write Text Lines to a Text File</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://deepr.gagolewski.com/">Deep R Programming</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stringx.gagolewski.com/">stringx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">JStatSoft Paper</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/ExampleRcppStringi">C++ API — Rcpp Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../news.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../z_bibliography.html">References</a></li>
</ul>

</div></div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/gagolews/stringi/issues/" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="code-pointwise-comparing">
<span id="sec-fixed"></span><h1>Code-Pointwise Comparing<a class="headerlink" href="#code-pointwise-comparing" title="Link to this heading">#</a></h1>
<blockquote>
<div><p>This tutorial is based on the <a class="reference external" href="https://dx.doi.org/10.18637/jss.v103.i02">paper on <em>stringi</em></a> that was published in the <em>Journal of Statistical Software</em>; see <span id="id1">[<a class="reference internal" href="../z_bibliography.html#id3" title="Gagolewski, M. (2022).  stringi: Fast and portable character string processing in R. Journal of Statistical Software, 103(2):1–59. DOI: 10.18637/jss.v103.i02.">2</a>]</span>. To learn more about R, check out Marek’s open-access (free!) textbook <a class="reference external" href="https://deepr.gagolewski.com/"><em>Deep R Programming</em></a> <span id="id2">[<a class="reference internal" href="../z_bibliography.html#id4" title="Gagolewski, M. (2023).  Deep R Programming. Zenodo, Melbourne. ISBN 978-0-6455719-2-9. URL: https://deepr.gagolewski.com/, DOI: 10.5281/zenodo.7490464.">3</a>]</span>.</p>
</div></blockquote>
<p>There are many settings where we are faced with testing whether two
strings (or parts thereof) consist of exactly the same Unicode code
points, in exactly the same order. These include, for instance, matching
a nucleotide sequence in a DNA profile and querying for system resources
based on file names or UUIDs. Such tasks, due to their simplicity, can
be performed very efficiently.</p>
<section id="testing-for-equality-of-strings">
<h2>Testing for Equality of Strings<a class="headerlink" href="#testing-for-equality-of-strings" title="Link to this heading">#</a></h2>
<p>To quickly test whether the corresponding strings in two character
vectors are identical (in a code-pointwise manner), we can use the
<code class="docutils literal notranslate"><span class="pre">%s===%</span></code> operator or, equivalently, the <code class="docutils literal notranslate"><span class="pre">stri_cmp_eq()</span></code> function.
Moreover, <code class="docutils literal notranslate"><span class="pre">%s!==%</span></code> and <code class="docutils literal notranslate"><span class="pre">stri_cmp_neq()</span></code> implement the not-equal-to
relation.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;actg&quot;</span><span class="w"> </span><span class="o">%s===%</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;ACTG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;actg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;act&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;actga&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span>
<span class="c1">## [1] FALSE  TRUE FALSE FALSE    NA</span>
</pre></div>
</div>
<p>Due to recycling, the first string was compared against the five strings in
the 2nd operand. There is only one exact match.</p>
</section>
<section id="searching-for-fixed-strings">
<span id="sec-strsearch"></span><h2>Searching for Fixed Strings<a class="headerlink" href="#searching-for-fixed-strings" title="Link to this heading">#</a></h2>
<p>For detecting if a string contains a given fixed substring
(code-pointwisely), the fast KMP <span id="id3">[<a class="reference internal" href="../z_bibliography.html#id24" title="Knuth, D., Morris, J.H., and Pratt, V. (1977).  Fast pattern matching in strings. SIAM Journal on Computing, 6(2):323–350.">7</a>]</span> algorithm, with
worst time complexity of <em>O(n+p)</em> (where <em>n</em> is the length of the string
and <em>p</em> is the length of the pattern), has been implemented in <em>stringi</em>
(with numerous tweaks for even faster matching).</p>
<p>The table below lists the string search functions available
in <em>stringi</em>. Below we explain their behaviour in the context of fixed
pattern matching. Notably, their description is quite detailed because
– as we shall soon find out – the corresponding operations are
available for the two other search engines: based on regular expressions
and the <em>ICU</em> Collator, see <a class="reference internal" href="regular_expressions.html#sec-regex"><span class="std std-ref">Regular Expressions</span></a> and <a class="reference internal" href="collation.html#sec-collator"><span class="std std-ref">Collation</span></a>.</p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name(s)</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stri_count()</span></code></p></td>
<td><p>count pattern matches</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stri_detect()</span></code></p></td>
<td><p>detect pattern matches</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stri_endswith()</span></code></p></td>
<td><p>[all but <code class="docutils literal notranslate"><span class="pre">regex</span></code>] detect pattern matches at end of string</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stri_extract_all()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_extract_first()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_extract_last()</span></code></p></td>
<td><p>extract pattern matches</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stri_locate_all()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_locate_first()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_locate_last()</span></code></p></td>
<td><p>locate pattern matches</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stri_match_all()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_match_first()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_match_last()</span></code></p></td>
<td><p>[<code class="docutils literal notranslate"><span class="pre">regex</span></code> only] extract matches to regex capture groups</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stri_replace_all()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_replace_first()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_replace_last()</span></code></p></td>
<td><p>substitute pattern matches with some replacement strings</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stri_split()</span></code></p></td>
<td><p>split up a string at pattern matches</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stri_startswith()</span></code></p></td>
<td><p>[all but <code class="docutils literal notranslate"><span class="pre">regex</span></code>] detect pattern matches at start of string</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stri_subset()</span></code>, <code class="docutils literal notranslate"><span class="pre">‘stri_subset&lt;-‘()</span></code></p></td>
<td><p>return or replace strings that contain pattern matches</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="counting-matches">
<h2>Counting Matches<a class="headerlink" href="#counting-matches" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">stri_count_fixed()</span></code> function counts the number of times a fixed
pattern occurs in a given string.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_fixed</span><span class="p">(</span><span class="s">&quot;abcabcdefabcabcabdc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># search pattern is &quot;abc&quot;</span>
<span class="c1">## [1] 4</span>
</pre></div>
</div>
<p>Equivalently, we can call the more generic (see below) function
<code class="docutils literal notranslate"><span class="pre">stri_count()</span></code> with the <code class="docutils literal notranslate"><span class="pre">fixed=pattern</span></code> argument:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count</span><span class="p">(</span><span class="s">&quot;abcabcdefabcabcabdc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fixed</span><span class="o">=</span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="c1">## [1] 4</span>
</pre></div>
</div>
<p>Note that, unlike in the base R <code class="docutils literal notranslate"><span class="pre">grep()</span></code> function (and the like), the
pattern (“needle”) is given by the second argument (here: “<code class="docutils literal notranslate"><span class="pre">abc</span></code>”). This
makes our function more pipe-operator-friendly, because “haystack” can
be forwarded as follows:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;abcabcdefabcabcabdc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cba&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nf">stri_count_fixed</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="c1">## [1]  4  0 NA</span>
</pre></div>
</div>
</section>
<section id="search-engine-options">
<h2>Search Engine Options<a class="headerlink" href="#search-engine-options" title="Link to this heading">#</a></h2>
<p>The pattern matching engine may be tuned up by passing further arguments
to the search functions (via “<code class="docutils literal notranslate"><span class="pre">...</span></code>”; they are redirected as-is to
<code class="docutils literal notranslate"><span class="pre">stri_opts_fixed()</span></code>). The table below gives the list of available options.</p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Option</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code></p></td>
<td><p>logical; whether to enable the simple case-insensitive matching (defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">overlap</span></code></p></td>
<td><p>logical; whether to enable the detection of overlapping matches (defaults to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>); available in <code class="docutils literal notranslate"><span class="pre">stri_extract_all_fixed()</span></code>, <code class="docutils literal notranslate"><span class="pre">stri_locate_all_fixed()</span></code>, and <code class="docutils literal notranslate"><span class="pre">stri_count_fixed()</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>First, we may switch on the simplistic<a class="footnote-reference brackets" href="#footfixedcase" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> case-insensitive matching.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_fixed</span><span class="p">(</span><span class="s">&quot;ACTGACGacgggACg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;acg&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
<p>Second, we can indicate our interest in detecting overlapping pattern
matches or whether searching should continue at the end of each match
(the latter being the default behaviour):</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_count_fixed</span><span class="p">(</span><span class="s">&quot;acatgacaca&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aca&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># overlap=FALSE (default)</span>
<span class="c1">## [1] 2</span>
<span class="nf">stri_count_fixed</span><span class="p">(</span><span class="s">&quot;acatgacaca&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aca&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">overlap</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] 3</span>
</pre></div>
</div>
</section>
<section id="detecting-and-subsetting-patterns">
<h2>Detecting and Subsetting Patterns<a class="headerlink" href="#detecting-and-subsetting-patterns" title="Link to this heading">#</a></h2>
<p>A somewhat simplified version of the above search task asks
whether a pattern occurs in a string at all. Such an operation can be
performed with a call to <code class="docutils literal notranslate"><span class="pre">stri_detect_fixed()</span></code>.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;def&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;xyzabc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uabdc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dab&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="nf">stri_detect_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="c1">## [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE    NA  TRUE</span>
</pre></div>
</div>
<p>We can also indicate that a no-match is rather of our interest by
passing <code class="docutils literal notranslate"><span class="pre">negate=TRUE</span></code>. What is more, there is an option to stop
searching once a given number of matches has been found in the
<code class="docutils literal notranslate"><span class="pre">haystack</span></code> vector (as a whole), which can speed up the processing of
larger data sets:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_detect_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">negate</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">max_count</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="c1">## [1] FALSE FALSE  TRUE FALSE  TRUE    NA    NA    NA</span>
</pre></div>
</div>
<p>This can be useful in scenarios such as “find the first 2 matching
resource IDs”.</p>
<p>There are also functions that verify whether a string starts or ends<a class="footnote-reference brackets" href="#footanchor" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
with a pattern match:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_startswith_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># from=1 - match at start</span>
<span class="c1">## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE    NA  TRUE</span>
<span class="nf">stri_endswith_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1"># to=-1 - match at end</span>
<span class="c1">## [1]  TRUE FALSE FALSE  TRUE FALSE FALSE    NA  TRUE</span>
</pre></div>
</div>
<p>Pattern detection is often performed in conjunction with character
vector subsetting. This is why we have a specialised (and hence slightly
faster) function that returns only the strings that match a given
pattern.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_subset_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omit_na</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] &quot;abc&quot;    &quot;abcd&quot;   &quot;xyzabc&quot; &quot;abc&quot;</span>
</pre></div>
</div>
<p>The above is equivalent to <code class="docutils literal notranslate"><span class="pre">x[which(stri_detect_fixed(x,</span> <span class="pre">&quot;abc&quot;))]</span></code> (note
the argument responsible for the removal of missing values), but avoids
writing <code class="docutils literal notranslate"><span class="pre">x</span></code> twice. It is particularly convenient when <code class="docutils literal notranslate"><span class="pre">x</span></code> is
generated programmatically on the fly, using some complicated
expression. Also, it works well with the forward pipe operator, as we
can write “<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|&gt;</span> <span class="pre">stri_subset_fixed(&quot;abc&quot;,</span> <span class="pre">omit_na=TRUE)</span></code>”.</p>
<p>There is also a replacement version of this function:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_subset_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;*****&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;***&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># modifies x in-place</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="c1"># x has changed</span>
<span class="c1">## [1] &quot;*****&quot; &quot;***&quot;   &quot;def&quot;   &quot;*****&quot; &quot;uabdc&quot; &quot;dab&quot;   NA      &quot;***&quot;</span>
</pre></div>
</div>
</section>
<section id="locating-and-extracting-patterns">
<h2>Locating and Extracting Patterns<a class="headerlink" href="#locating-and-extracting-patterns" title="Link to this heading">#</a></h2>
<p>The functions from the <code class="docutils literal notranslate"><span class="pre">stri_locate()</span></code> family aim to pinpoint the
positions of pattern matches. First, we may be interested in getting to
know the location of the first or the last pattern occurrence:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;actg&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;AGagaGAgaga&quot;</span><span class="p">)</span>
<span class="nf">stri_locate_first_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">)</span>
<span class="c1">##      start end</span>
<span class="c1">## [1,]     1   3</span>
<span class="c1">## [2,]    NA  NA</span>
<span class="c1">## [3,]    NA  NA</span>
<span class="c1">## [4,]     3   5</span>
<span class="nf">stri_locate_last_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">get_length</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">##      start length</span>
<span class="c1">## [1,]     1      3</span>
<span class="c1">## [2,]    -1     -1</span>
<span class="c1">## [3,]    NA     NA</span>
<span class="c1">## [4,]     9      3</span>
</pre></div>
</div>
<p>In both examples, we obtain a two-column matrix with the number of rows
determined by the recycling rule (here: the length of <code class="docutils literal notranslate"><span class="pre">x</span></code>). In the
former case, we get a “from–to” matrix (<code class="docutils literal notranslate"><span class="pre">get_length=FALSE</span></code>; the
default) where missing values correspond to either missing inputs or
no-matches. The latter gives a “from–length”-type matrix, where
negative lengths correspond to the not-founds.</p>
<p>Second, we may be yearning for the locations of all the matching
substrings. As the number of possible answers may vary from string to
string, the result is a list of index matrices.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_locate_all_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">overlap</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">##      start end</span>
<span class="c1">## [1,]     1   3</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">##      start end</span>
<span class="c1">## [1,]    NA  NA</span>
<span class="c1">## </span>
<span class="c1">## [[3]]</span>
<span class="c1">##      start end</span>
<span class="c1">## [1,]    NA  NA</span>
<span class="c1">## </span>
<span class="c1">## [[4]]</span>
<span class="c1">##      start end</span>
<span class="c1">## [1,]     1   3</span>
<span class="c1">## [2,]     3   5</span>
<span class="c1">## [3,]     5   7</span>
<span class="c1">## [4,]     7   9</span>
<span class="c1">## [5,]     9  11</span>
</pre></div>
</div>
<p>Note again that a no-match is indicated by a single-row matrix with two
missing values (or with negative length if <code class="docutils literal notranslate"><span class="pre">get_length=TRUE</span></code>). This
behaviour can be changed by setting the <code class="docutils literal notranslate"><span class="pre">omit_no_match</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">TRUE</span></code>.</p>
<p>Let us recall that “from–to” and “from–length” matrices of the above
kind constitute particularly fine inputs to <code class="docutils literal notranslate"><span class="pre">stri_sub()</span></code> and
<code class="docutils literal notranslate"><span class="pre">stri_sub_all()</span></code>. However, if merely the extraction of the matching
substrings is needed, it will be more convenient to rely on the
functions from the <code class="docutils literal notranslate"><span class="pre">stri_extract()</span></code> family:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_extract_first_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] &quot;aga&quot; NA    NA    &quot;AGa&quot;</span>
<span class="nf">stri_extract_all_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="n">overlap</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">omit_no_match</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;aga&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## character(0)</span>
<span class="c1">## </span>
<span class="c1">## [[3]]</span>
<span class="c1">## [1] NA</span>
<span class="c1">## </span>
<span class="c1">## [[4]]</span>
<span class="c1">## [1] &quot;AGa&quot; &quot;aga&quot; &quot;aGA&quot; &quot;Aga&quot; &quot;aga&quot;</span>
</pre></div>
</div>
</section>
<section id="replacing-pattern-occurrences">
<h2>Replacing Pattern Occurrences<a class="headerlink" href="#replacing-pattern-occurrences" title="Link to this heading">#</a></h2>
<p>In order to replace each match with a corresponding replacement string,
we can refer to <code class="docutils literal notranslate"><span class="pre">stri_replace_all()</span></code>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;actg&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ggAGAGAgaGAca&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agagagaga&quot;</span><span class="p">)</span>
<span class="nf">stri_replace_all_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aga&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;~&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">case_insensitive</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [1] &quot;~&quot;         &quot;actg&quot;      NA          &quot;gg~G~GAca&quot; &quot;~g~ga&quot;</span>
</pre></div>
</div>
<p>Note that the inputs that are not part of any match are left unchanged.
The input object is left unchanged because it is not a replacement
function per se.</p>
<p>The operation is vectorised with respect to all the three arguments
(haystack, needle, replacement string), with the usual recycling
behaviour if necessary. If a different arguments’ vectorisation scheme
is required, we can set the <code class="docutils literal notranslate"><span class="pre">vectorise_all</span></code> argument of
<code class="docutils literal notranslate"><span class="pre">stri_replace_all()</span></code> to <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>. Compare the following:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">stri_replace_all_fixed</span><span class="p">(</span><span class="s">&quot;The quick brown fox jumped over the lazy dog.&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;quick&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;brown&quot;</span><span class="p">,</span><span class="w">      </span><span class="s">&quot;fox&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="w">    </span><span class="s">&quot;dog&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;slow&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;yellow-ish&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hen&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spamity&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;llama&quot;</span><span class="p">))</span>
<span class="c1">## [1] &quot;The slow brown fox jumped over the lazy dog.&quot;      </span>
<span class="c1">## [2] &quot;The quick yellow-ish fox jumped over the lazy dog.&quot;</span>
<span class="c1">## [3] &quot;The quick brown hen jumped over the lazy dog.&quot;     </span>
<span class="c1">## [4] &quot;The quick brown fox jumped over the spamity dog.&quot;  </span>
<span class="c1">## [5] &quot;The quick brown fox jumped over the lazy llama.&quot;</span>
<span class="nf">stri_replace_all_fixed</span><span class="p">(</span><span class="s">&quot;The quick brown fox jumped over the lazy dog.&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;quick&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;brown&quot;</span><span class="p">,</span><span class="w">      </span><span class="s">&quot;fox&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dog&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;slow&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;yellow-ish&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hen&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spamity&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;llama&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="n">vectorise_all</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
<span class="c1">## [1] &quot;The slow yellow-ish hen jumped over the spamity llama.&quot;</span>
</pre></div>
</div>
<p>Here, for every string in the <code class="docutils literal notranslate"><span class="pre">haystack</span></code>, we observe the vectorisation
independently over the <code class="docutils literal notranslate"><span class="pre">needles</span></code> and replacement strings. Each
occurrence of the 1st needle is superseded by the 1st replacement
string, then the search is repeated for the 2nd needle so as to replace
it with the 2nd corresponding replacement string, and so forth.</p>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">stri_replace_first()</span></code> and <code class="docutils literal notranslate"><span class="pre">stri_replace_last()</span></code> can identify
and replace the first and the last match, respectively.</p>
</section>
<section id="splitting">
<h2>Splitting<a class="headerlink" href="#splitting" title="Link to this heading">#</a></h2>
<p>To split each element in the <code class="docutils literal notranslate"><span class="pre">haystack</span></code> into substrings, where the
<code class="docutils literal notranslate"><span class="pre">needles</span></code> define the delimiters that separate the inputs into tokens, we
call <code class="docutils literal notranslate"><span class="pre">stri_split()</span></code>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a,b,c,d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;f,g,,,h,i,,j,&quot;</span><span class="p">)</span>
<span class="nf">stri_split_fixed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omit_empty</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;e&quot;</span>
<span class="c1">## </span>
<span class="c1">## [[3]]</span>
<span class="c1">## character(0)</span>
<span class="c1">## </span>
<span class="c1">## [[4]]</span>
<span class="c1">## [1] NA</span>
<span class="c1">## </span>
<span class="c1">## [[5]]</span>
<span class="c1">## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot;</span>
</pre></div>
</div>
<p>The result is a list of character vectors, as each string in the
<code class="docutils literal notranslate"><span class="pre">haystack</span></code> might be split into a possibly different number of tokens.</p>
<p>There is also an option to limit the number of tokens (parameter <code class="docutils literal notranslate"><span class="pre">n</span></code>).</p>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footfixedcase" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>Which is not suitable for real-world NLP tasks,
as it assumes that
changing the case of a single code point always produces one and
only one item. This way, <code class="docutils literal notranslate"><span class="pre">&quot;groß&quot;</span></code> does not compare equal to
<code class="docutils literal notranslate"><span class="pre">&quot;GROSS&quot;</span></code>, see <a class="reference internal" href="collation.html#sec-collator"><span class="std std-ref">Collation</span></a> (and to some extent
<a class="reference internal" href="regular_expressions.html#sec-regex"><span class="std std-ref">Regular Expressions</span></a>) for a workaround.</p>
</aside>
<aside class="footnote brackets" id="footanchor" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">2</a><span class="fn-bracket">]</span></span>
<p>Note that testing for a pattern match at the start or end of a
string has not been implemented separately for <code class="docutils literal notranslate"><span class="pre">regex</span></code> patterns,
which support <code class="docutils literal notranslate"><span class="pre">&quot;^&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;$&quot;</span></code> anchors that serve precisely this
purpose; see <a class="reference internal" href="regular_expressions.html#sec-regex"><span class="std std-ref">Regular Expressions</span></a>.</p>
</aside>
</aside>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="regular_expressions.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Regular Expressions</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="basic_operations.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Basic String Operations</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              
              
              Copyright &#169; 2013–2023 by <a href="https://www.gagolewski.com">Marek Gagolewski</a>.
              Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0/'>CC BY-NC-ND 4.0</a>.
              Built with <a href="https://sphinx-doc.org/">Sphinx</a>
              and a customised <a href="https://github.com/pradyunsg/furo">Furo</a> theme.
              Last updated on 2023-11-02T13:33:26+1100.
              This site will never display any ads: it is a non-profit project.
              It does not collect any data.
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            In this section
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Code-Pointwise Comparing</a><ul>
<li><a class="reference internal" href="#testing-for-equality-of-strings">Testing for Equality of Strings</a></li>
<li><a class="reference internal" href="#searching-for-fixed-strings">Searching for Fixed Strings</a></li>
<li><a class="reference internal" href="#counting-matches">Counting Matches</a></li>
<li><a class="reference internal" href="#search-engine-options">Search Engine Options</a></li>
<li><a class="reference internal" href="#detecting-and-subsetting-patterns">Detecting and Subsetting Patterns</a></li>
<li><a class="reference internal" href="#locating-and-extracting-patterns">Locating and Extracting Patterns</a></li>
<li><a class="reference internal" href="#replacing-pattern-occurrences">Replacing Pattern Occurrences</a></li>
<li><a class="reference internal" href="#splitting">Splitting</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=d8accc85"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>